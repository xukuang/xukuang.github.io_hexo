

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>YiYuZhiJian</title>
  <meta name="author" content="kuang xu">
  
  <meta name="description" content="Walk steps step by step">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="YiYuZhiJian"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="YiYuZhiJian" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//libs.baidu.com/jquery/1.8.0/jquery.min.js"></script>
</head>


<body>
  <header id="header" class="inner">
<div class="alignleft">
  <h1><a href="/">YiYuZhiJian</a></h1>
  <h2><a href="/">你害怕一件事，可还是要去做，那才是勇敢。</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
	    <li> <a href="/atom.xml">RSS</a> </li>
<li> <a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() {
	function c() {
		var e = document.createElement("link");
		e.setAttribute("type", "text/css");
		e.setAttribute("rel", "stylesheet");
		e.setAttribute("href", f);
		e.setAttribute("class", l);
		document.body.appendChild(e)
	}
 
	function h() {
		var e = document.getElementsByClassName(l);
		for (var t = 0; t < e.length; t++) {
			document.body.removeChild(e[t])
		}
	}
 
	function p() {
		var e = document.createElement("div");
		e.setAttribute("class", a);
		document.body.appendChild(e);
		setTimeout(function() {
			document.body.removeChild(e)
		}, 100)
	}
 
	function d(e) {
		return {
			height : e.offsetHeight,
			width : e.offsetWidth
		}
	}
 
	function v(i) {
		var s = d(i);
		return s.height > e && s.height < n && s.width > t && s.width < r
	}
 
	function m(e) {
		var t = e;
		var n = 0;
		while (!!t) {
			n += t.offsetTop;
			t = t.offsetParent
		}
		return n
	}
 
	function g() {
		var e = document.documentElement;
		if (!!window.innerWidth) {
			return window.innerHeight
		} else if (e && !isNaN(e.clientHeight)) {
			return e.clientHeight
		}
		return 0
	}
 
	function y() {
		if (window.pageYOffset) {
			return window.pageYOffset
		}
		return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
	}
 
	function E(e) {
		var t = m(e);
		return t >= w && t <= b + w
	}
 
	function S() {
		var e = document.createElement("audio");
		e.setAttribute("class", l);
		e.src = i;
		e.loop = false;
		e.addEventListener("canplay", function() {
			setTimeout(function() {
				x(k)
			}, 500);
			setTimeout(function() {
				N();
				p();
				for (var e = 0; e < O.length; e++) {
					T(O[e])
				}
			}, 15500)
		}, true);
		e.addEventListener("ended", function() {
			N();
			h()
		}, true);
		e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
		document.body.appendChild(e);
		e.play()
	}
 
	function x(e) {
		e.className += " " + s + " " + o
	}
 
	function T(e) {
		e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
	}
 
	function N() {
		var e = document.getElementsByClassName(s);
		var t = new RegExp("\\b" + s + "\\b");
		for (var n = 0; n < e.length; ) {
			e[n].className = e[n].className.replace(t, "")
		}
	}
 
	var e = 30;
	var t = 30;
	var n = 350;
	var r = 350;
	var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";
	var s = "mw-harlem_shake_me";
	var o = "im_first";
	var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
	var a = "mw-strobe_light";
	var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
	var l = "mw_added_css";
	var b = g();
	var w = y();
	var C = document.getElementsByTagName("*");
	var k = null;
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			if (E(A)) {
				k = A;
				break
			}
		}
	}
	if (A === null) {
		console.warn("Could not find a node of the right size. Please try a different page.");
		return
	}
	c();
	S();
	var O = [];
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			O.push(A)
		}
	}
})()    '>High一下</a> </li>

  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-27T19:04:53.000Z"><a href="/2016/04/27/numpy/">4月27 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/27/numpy/">Numpy包的学习</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Numpy 是 Numerical python 的简称，是高性能计算和数据分析的基础包。</p>
<ul>
<li>ndarray，快速和节省空间的多维数组，提供数组化的算术运算和高级的广播功能『广播功能是个什么东东啊』</li>
<li>使用标准数学函数对整个数组的数据进行快速运算，而不需要编写循环</li>
<li>读取/写入磁盘上的阵列数据和操作存储器映像文件的工具</li>
<li>线性代数，随机数生成，和傅里叶变换的能力</li>
<li>集成C，C++，Fortran代码的工具</li>
</ul>
<p>从生态系统的角度看，最后一点是最为重要的。因为Numpy提供了易用的C ApI，它可以很容易的将数据传递到使用低级语言编写的外部库，也可以使外部库返回Numpy数组数据到python。这一特性使得python成为包装传统的C/C++/Fortran代码库，并给它们一个动态的、易于使用的接口的首选语言。『完全不懂啊』<br>虽然Numpy本身并没有提供非常高级的数据分析功能，但是了解Numpy的数组和面向数组的计算将会帮助你高效的使用类似于pandas这样的工具。<br>对于大多数的数据分析应用来说，我关注的主要功能是。</p>
<ul>
<li>快速的矢量化数组操作：数据切割和清除，子集和过滤，转化和任何其它类型的计算</li>
<li>通用的数组算法，例如：sorting，unique和set操作</li>
<li>有效的描述性统计和聚集/汇总数据</li>
<li>数据对齐、关系数据的合并操作、异构数据的拼接操作</li>
<li>使用数组表达式来表示条件逻辑，而不是用带有 if-elif-else 分支的循环来表示</li>
<li>组间数据的操作（聚合，转换，功能应用）。</li>
</ul>
<p>虽然Numpy提供了这些操作的计算功能，但你或许希望使用pandas作为大多数数据分析的基础（特别是结构化或表格数据），因为pandas提供了一个丰富的，高级的接口使得常见的数据任务非常简洁和简单。此外，pandas还提供了更多的一些特定领域的功能，如时间数组操作，这是Numpy所没有的。</p>
<h3 id="Numpy_ndarray：多维数组对象">Numpy ndarray：多维数组对象</h3><p>Numpy的一个关键特性是它的N维数组对象(ndarray)，它在python中是一个大型数据集的快速的，灵活的容器。 数组使你能够在整个数据块上进行数学运算，且与对应的纯量元素间操作有相似的语法：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array1 = np.array(<span class="string">[[ 0.9526, -0.246 , -0.8856], [ 0.5639, 0.2379, 0.9104]]</span>)</span><br><span class="line">array1</span><br><span class="line">	## array(<span class="string">[[ 0.9526, -0.246 , -0.8856],</span><br><span class="line">	## 		[ 0.5639,  0.2379,  0.9104]]</span>)</span><br><span class="line">array1 * <span class="number">10</span></span><br><span class="line">	## array(<span class="string">[[ 9.526, -2.46 , -8.856],</span><br><span class="line">	##        [ 5.639,  2.379,  9.104]]</span>)</span><br><span class="line">array1 + array1</span><br><span class="line">	## array(<span class="string">[[ 1.9052, -0.492 , -1.7712],</span><br><span class="line">	##        [ 1.1278,  0.4758,  1.8208]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>ndarray是一个同种类数据的多维容器，也就是说，它的所有元素都是同类型的。每一个数组都有一个 shape （表示它每一维大小的元组）和 dtype （一个描述数组数据类型的对象）的属性。<br><figure class="highlight ruleslanguage"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array1.shape</span><br><span class="line">	#<span class="array"># </span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">array1.dtype</span><br><span class="line">	#<span class="array"># dtype</span>(<span class="string">'float64'</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="创建ndarray对象">创建ndarray对象</h4><p>最简单的创建数组的方式是使用array函数。它接受任何数组对象（包括其它数组），产生一个包含所传递的数据的新Numpy数组。例如，列表就是一个很好的用于转换的候选。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">data1 =</span> [<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="variable">arr1 =</span> np.array(data1)</span><br><span class="line">arr1</span><br><span class="line">	<span class="comment">## array([ 6. , 7.5, 8. , 0. , 1. ])</span></span><br></pre></td></tr></table></figure></p>
<p>嵌套序列，如等长列表的列表，将会转化为一个多维数组。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data2 = <span class="string">[[1, 2, 3, 4], [5, 6, 7, 8]]</span></span><br><span class="line">arr2 = np.array(data2)</span><br><span class="line">arr2</span><br><span class="line">	## array(<span class="string">[[1, 2, 3, 4],</span><br><span class="line">	##        [5, 6, 7, 8]]</span>)</span><br><span class="line">arr2.ndim</span><br><span class="line">	## <span class="number">2</span></span><br><span class="line">arr2.shape</span><br><span class="line">	## (<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>除 np.array 之外，还有许多函数来创建新的数组。例如， zeros 和 ones 使用给定的长度或形状分别的创建0‘s 和 1‘s数组。empty 会创建一个没有使用特定值来初始化的数组。给这些方法传递一个元组作为形状来创建高维数组。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">np.zeros(<span class="number">10</span>)</span><br><span class="line">	## array([ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">np.zeros((<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">	## array(<span class="string">[[ 0., 0., 0., 0., 0., 0.],</span><br><span class="line">	##        [ 0., 0., 0., 0., 0., 0.],</span><br><span class="line">	##        [ 0., 0., 0., 0., 0., 0.]]</span>)</span><br><span class="line">np.empty((<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">	## array(<span class="string">[[[ 4.94065646e-324, 4.94065646e-324],</span><br><span class="line">	##         [ 3.87491056e-297, 2.46845796e-130],</span><br><span class="line">	##         [ 4.94065646e-324, 4.94065646e-324]]</span>,</span><br><span class="line">	##        <span class="string">[[ 1.90723115e+083, 5.73293533e-053],</span><br><span class="line">	##         [ -2.33568637e+124, -6.70608105e-012],</span><br><span class="line">	##         [ 4.42786966e+160, 1.27100354e+025]]</span>])</span><br></pre></td></tr></table></figure></p>
<p>arange 是python内建 range 函数的数组版本。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np<span class="class">.arange</span>(15)</span><br><span class="line">	## <span class="function">array</span>(<span class="attr_selector">[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="数组和纯量间的操作">数组和纯量间的操作</h4><p>数组非常重要，因为它们使你不使用循环就可以在数据上进行一系列操作。这通常被叫做矢量化。相同大小的数组间的算术运算，其操作作用在对应的元素上。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array(<span class="string">[[1., 2., 3.], [4., 5., 6.]]</span>)</span><br><span class="line">arr</span><br><span class="line">	## array(<span class="string">[[ 1.,  2.,  3.],</span><br><span class="line">	##        [ 4.,  5.,  6.]]</span>)</span><br><span class="line">arr * arr                 </span><br><span class="line">	## array(<span class="string">[[  1.,   4.,   9.],       </span><br><span class="line">	##        [ 16.,  25.,  36.]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>纯量的算术操作正如你期望的一样，把操作值作用于每一个元素：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / arr                       </span><br><span class="line">	## array(<span class="string">[[ 1. , 0.5 , 0.3333],            </span><br><span class="line">	##        [ 0.25 , 0.2 , 0.1667]]</span>)</span><br></pre></td></tr></table></figure>
<h4 id="基本的索引和切片">基本的索引和切片</h4><p>Numpy的索引是一个内容丰富的主题，因为有许多方法可以使你在你的数据中选取一个子集或单个元素。一维的数组很简单，表面上它们的行为类似于python的列表。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">arr</span> = <span class="atom">np</span>.<span class="atom">arange</span>(<span class="number">10</span>)</span><br><span class="line"><span class="atom">arr</span></span><br><span class="line">	## <span class="atom">array</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="atom">arr</span>[<span class="number">5</span>]</span><br><span class="line">	## <span class="number">5</span></span><br><span class="line"><span class="atom">arr</span>[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">	## <span class="atom">array</span>([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="atom">arr</span>[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span></span><br><span class="line"><span class="atom">arr</span></span><br><span class="line">	## <span class="atom">array</span>([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br></pre></td></tr></table></figure></p>
<p>如你所见，当你给一个切片赋一纯量值，如 arr[5:8] = 12 所示，该值被传送(或传播)到整个选择区域。与列表的第一个重要的区别是数组的切片在原来的数组上（不生成新的数组）。这意味着数据不会被拷贝，且对切片的任何修改都会影响源数组。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">arr_slice</span> = <span class="atom">arr</span>[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line"><span class="atom">arr_slice</span>[<span class="number">1</span>] = <span class="number">12345</span></span><br><span class="line"><span class="atom">arr_slice</span></span><br><span class="line">	## <span class="atom">array</span>([   <span class="number">12</span>, <span class="number">12345</span>,    <span class="number">12</span>])</span><br><span class="line"><span class="atom">arr</span></span><br><span class="line">	## <span class="atom">array</span>([ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">12345</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="atom">arr_slice</span>[:] = <span class="number">64</span></span><br><span class="line"><span class="atom">arr_slice</span></span><br><span class="line">	## <span class="atom">array</span>([<span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>])</span><br><span class="line"><span class="atom">arr</span></span><br><span class="line">	## <span class="atom">array</span>([ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure></p>
<p>如果你是使用Numpy的新手，这一点会使你感到惊讶『真的惊讶到我了』，尤其当你使用过其它数组编程语言，它们非常热衷于拷贝数据。请记住，Numpy是设计用来处理大数据的情况，你可以想象如果Numpy坚持使用拷贝数据将会出现的性能和内存问题。如果你想有数组切片的一个拷贝，你需要明显的拷贝数组；例如 arr[5:8].copy() 。</p>
<p>对于高维数组，你会有更多选项。在两维的数组，每一个索引的元素将不再是一个纯量，而是一个一维数组。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">arr2d</span> = <span class="atom">np</span>.<span class="atom">array</span>([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="atom">arr2d</span>[<span class="number">2</span>]</span><br><span class="line">	## <span class="atom">array</span>([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure></p>
<p>因此，单个元素可以递归的访问，但是这会做多一点的工作。不过，你可以使用一个逗号分隔的索引列表来选择单个元素。因此，下面的操作是等价的。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr2d[<span class="link_label">0</span>][<span class="link_reference">2</span>]</span><br><span class="line"><span class="code">	## 3</span></span><br><span class="line">arr2d[0, 2]</span><br><span class="line"><span class="code">	## 3</span></span><br></pre></td></tr></table></figure></p>
<p>在多维数组中，如果你省略了后面的索引，返回的对象将会是一个较低维的ndarray，它包括较高维度的所有数据。因此，在 2*\2*3 的数组 arr3d 中<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr3d = np.array(<span class="string">[[[1, 2, 3], [4, 5, 6]]</span>, <span class="string">[[7, 8, 9], [10, 11, 12]]</span>])</span><br><span class="line">arr3d</span><br><span class="line">	## array(<span class="string">[[[ 1, 2, 3],</span><br><span class="line">	##         [ 4, 5, 6]]</span>,</span><br><span class="line">	##        <span class="string">[[ 7, 8, 9],</span><br><span class="line">	##         [10, 11, 12]]</span>])</span><br></pre></td></tr></table></figure></p>
<p>arr3d[0] 是一个 2*3 的数组。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr3d[<span class="number">0</span>]</span><br><span class="line">	## array(<span class="string">[[1, 2, 3],</span><br><span class="line">	##        [4, 5, 6]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>纯量值和数组都可以给 arr3d[0] 赋值。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">old_values = arr3d[<span class="number">0</span>].copy()</span><br><span class="line">arr3d[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line">arr3d</span><br><span class="line">	## array(<span class="string">[[[42, 42, 42],</span><br><span class="line">	##         [42, 42, 42]]</span>,</span><br><span class="line">	##        <span class="string">[[ 7, 8, 9],</span><br><span class="line">	##         [10, 11, 12]]</span>])</span><br><span class="line">arr3d[<span class="number">0</span>] = old_values</span><br><span class="line">arr3d</span><br><span class="line">	## array(<span class="string">[[[ 1, 2, 3],</span><br><span class="line">	##         [ 4, 5, 6]]</span>,</span><br><span class="line">	##        <span class="string">[[ 7, 8, 9],</span><br><span class="line">	##         [10, 11, 12]]</span>])</span><br></pre></td></tr></table></figure></p>
<p>类似的， arr3d[1, 0] 给出那些索引以 (1, 0) 开始的值，形成了一个1维数组：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr3d<span class="attr_selector">[1, 0]</span></span><br><span class="line">	## <span class="function">array</span>(<span class="attr_selector">[7, 8, 9]</span>)</span><br></pre></td></tr></table></figure></p>
<p>请注意，在所有的情况下，被选中的子节返回的数组总是数组视窗。<br>如同一维对象，ndarrys可以使用熟悉的语法来切片。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr<span class="attr_selector">[1:6]</span></span><br><span class="line">	## <span class="function">array</span>(<span class="attr_selector">[ 1, 2, 3, 4, 64]</span>)</span><br></pre></td></tr></table></figure></p>
<p>较高维的对象给你更多的选择，你可以切割一个或多个坐标坐标轴，并且可以混合整数。对上面的2维数组，arr2d ，对它的切片有些不同。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr2d</span><br><span class="line">	## array(<span class="string">[[1, 2, 3],          </span><br><span class="line">	##        [4, 5, 6],                 </span><br><span class="line">	##        [7, 8, 9]]</span>)</span><br><span class="line">arr2d[:<span class="number">2</span>]</span><br><span class="line">	## array(<span class="string">[[1, 2, 3],</span><br><span class="line">	##        [4, 5, 6]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>正如你所见，它沿着0坐标坐标轴（第一个坐标坐标轴）切片。因此，一个切片沿着一个坐标坐标轴向选择一个范围的元素。你可以传递多个切片，就像你传递多个索引一样。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2d[:<span class="number">2</span>, <span class="number">1</span>:]</span><br><span class="line">	## array(<span class="string">[[2, 3],</span><br><span class="line">	##        [5, 6]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>像这样这样切片时，你得到的总是相同维数的数组视窗。通过混合整形索引和切片，你可以得到较低维的切片。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2d<span class="attr_selector">[1, :2]</span> </span><br><span class="line">	## <span class="function">array</span>(<span class="attr_selector">[4, 5]</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意，一个单一的冒号意味着取整个坐标/坐标轴，因此，你可以只切割更高维的坐标轴，做法如下：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr2d[:, :<span class="number">1</span>]</span><br><span class="line">	## array(<span class="string">[[1],</span><br><span class="line">	##        [4],</span><br><span class="line">	##        [7]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>当然，给一个切片表达式赋值会对整个选择赋值：<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">arr2d[:2, 1:] </span>=<span class="string"> 0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="布尔索引">布尔索引</h2><p>让我们来考虑一个例子，我们有一些数据在一个数组中和一个有重复名字的数组。我将会在这使用 numpy.random 中的 randn 函数来产生一些随机的正态分布的数据。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">import</span> <span class="atom">numpy</span>.<span class="atom">random</span> <span class="atom">as</span> <span class="atom">np_rd</span></span><br><span class="line"><span class="atom">names</span> = <span class="atom">np</span>.<span class="atom">array</span>([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line"><span class="atom">data</span> = <span class="atom">np_rd</span>.<span class="atom">randn</span>(<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line"><span class="atom">names</span></span><br><span class="line">	## <span class="atom">array</span>([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>],</span><br><span class="line">	##       <span class="atom">dtype</span>=<span class="string">'|S4'</span>)</span><br><span class="line"><span class="atom">data</span></span><br><span class="line">	## <span class="atom">array</span>([[-<span class="number">0.048</span> , <span class="number">0.5433</span>, -<span class="number">0.2349</span>, <span class="number">1.2792</span>],</span><br><span class="line">	##        [-<span class="number">0.268</span> , <span class="number">0.5465</span>, <span class="number">0.0939</span>, -<span class="number">2.0445</span>],</span><br><span class="line">	##        [-<span class="number">0.047</span> , -<span class="number">2.026</span> , <span class="number">0.7719</span>, <span class="number">0.3103</span>],</span><br><span class="line">	##        [ <span class="number">2.1452</span>, <span class="number">0.8799</span>, -<span class="number">0.0523</span>, <span class="number">0.0672</span>],</span><br><span class="line">	##        [-<span class="number">1.0023</span>, -<span class="number">0.1698</span>, <span class="number">1.1503</span>, <span class="number">1.7289</span>],</span><br><span class="line">	##        [ <span class="number">0.1913</span>, <span class="number">0.4544</span>, <span class="number">0.4519</span>, <span class="number">0.5535</span>],</span><br><span class="line">	##        [ <span class="number">0.5994</span>, <span class="number">0.8174</span>, -<span class="number">0.9297</span>, -<span class="number">1.2564</span>]])</span><br></pre></td></tr></table></figure></p>
<p>假设每一个名字都和data数组中的一行对应。如果我们想要选择与‘Bob’名字对应的所有行。象算术运算一样，数组的比较操作（例如 == ）也可以矢量化。因此，names和Bob字符窜的比较会产生一个布尔数组。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names == <span class="string">'Bob'</span></span><br><span class="line">	## <span class="keyword">array</span>([ <span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>], dtype=bool)</span><br></pre></td></tr></table></figure></p>
<p>当索引数组时可以传递这一布尔数组。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[names == <span class="string">'Bob'</span>]</span><br><span class="line">	## array(<span class="string">[[-0.048 , 0.5433, -0.2349, 1.2792],</span><br><span class="line">	##        [ 2.1452, 0.8799, -0.0523, 0.0672]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>布尔数组必须和它索引的坐标轴的长度相同。你甚至可以把布尔数组和切片或整数（或者整数序列）混合和匹配起来。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[names == <span class="string">'Bob'</span>, <span class="number">2</span>:]</span><br><span class="line">	## array(<span class="string">[[-0.2349, 1.2792],</span><br><span class="line">	##        [-0.0523, 0.0672]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>为了选择除了 ‘Bob’ 之外的所有东西，你可以使用 ！= 或用 - 对条件表达式取反：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">names != <span class="string">'Bob'</span></span><br><span class="line">	## <span class="keyword">array</span>([<span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">True</span>], dtype=bool)</span><br><span class="line">data[-(names == <span class="string">'Bob'</span>)]</span><br><span class="line">	## <span class="keyword">array</span>([[-<span class="number">0.268</span> , <span class="number">0.5465</span>, <span class="number">0.0939</span>, -<span class="number">2.0445</span>],</span><br><span class="line">	##        [-<span class="number">0.047</span> , -<span class="number">2.026</span> , <span class="number">0.7719</span>, <span class="number">0.3103</span>],</span><br><span class="line">	##        [-<span class="number">1.0023</span>, -<span class="number">0.1698</span>, <span class="number">1.1503</span>, <span class="number">1.7289</span>],</span><br><span class="line">	##        [ <span class="number">0.1913</span>, <span class="number">0.4544</span>, <span class="number">0.4519</span>, <span class="number">0.5535</span>],</span><br><span class="line">	##        [ <span class="number">0.5994</span>, <span class="number">0.8174</span>, -<span class="number">0.9297</span>, -<span class="number">1.2564</span>]])</span><br></pre></td></tr></table></figure></p>
<p>使用布尔算术操作符如 &amp; （and） 和 | （or）来结合多个布尔条件，下面是从三个名字中选取两个的操作。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mask = (names == <span class="string">'Bob'</span>) | (names == <span class="string">'Will'</span>)</span><br><span class="line">mask</span><br><span class="line"><span class="keyword">array</span>([<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>], dtype=bool)</span><br><span class="line">data[mask]</span><br><span class="line">	<span class="comment">## array([[-0.048 , 0.5433, -0.2349, 1.2792],</span></span><br><span class="line">	<span class="comment">##        [-0.047 , -2.026 , 0.7719, 0.3103],</span></span><br><span class="line">	<span class="comment">##        [ 2.1452, 0.8799, -0.0523, 0.0672],</span></span><br><span class="line">	<span class="comment">##        [-1.0023, -0.1698, 1.1503, 1.7289]])</span></span><br></pre></td></tr></table></figure></p>
<p>通过布尔索引从一个数组中选取数据总是会创建数据的一份拷贝，即使是返回的数组没有改变。<br>为了设置 data 中所有的负值为0，我们只需要。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">data</span>[<span class="atom">data</span> &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="atom">data</span></span><br><span class="line">	## <span class="atom">array</span>([[ <span class="number">0.</span> , <span class="number">0.5433</span>, <span class="number">0.</span> , <span class="number">1.2792</span>],</span><br><span class="line">	##        [ <span class="number">0.</span> , <span class="number">0.5465</span>, <span class="number">0.0939</span>, <span class="number">0.</span> ],</span><br><span class="line">	##        [ <span class="number">0.</span> , <span class="number">0.</span> , <span class="number">0.7719</span>, <span class="number">0.3103</span>],</span><br><span class="line">	##        [ <span class="number">2.1452</span>, <span class="number">0.8799</span>, <span class="number">0.</span> , <span class="number">0.0672</span>],</span><br><span class="line">	##        [ <span class="number">0.</span> , <span class="number">0.</span> , <span class="number">1.1503</span>, <span class="number">1.7289</span>],</span><br><span class="line">	##        [ <span class="number">0.1913</span>, <span class="number">0.4544</span>, <span class="number">0.4519</span>, <span class="number">0.5535</span>],</span><br><span class="line">	##        [ <span class="number">0.5994</span>, <span class="number">0.8174</span>, <span class="number">0.</span> , <span class="number">0.</span> ]])</span><br></pre></td></tr></table></figure></p>
<p>使用一维布尔数组设置整行或列也非常简单：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">data</span>[<span class="atom">names</span> != <span class="string">'Joe'</span>] = <span class="number">7</span></span><br><span class="line"><span class="atom">data</span></span><br><span class="line"><span class="atom">array</span>([[ <span class="number">7.</span> , <span class="number">7.</span> , <span class="number">7.</span> , <span class="number">7.</span> ],</span><br><span class="line">       [ <span class="number">0.</span> , <span class="number">0.5465</span>, <span class="number">0.0939</span>, <span class="number">0.</span> ],</span><br><span class="line">       [ <span class="number">7.</span> , <span class="number">7.</span> , <span class="number">7.</span> , <span class="number">7.</span> ],</span><br><span class="line">       [ <span class="number">7.</span> , <span class="number">7.</span> , <span class="number">7.</span> , <span class="number">7.</span> ],</span><br><span class="line">       [ <span class="number">7.</span> , <span class="number">7.</span> , <span class="number">7.</span> , <span class="number">7.</span> ],</span><br><span class="line">       [ <span class="number">0.1913</span>, <span class="number">0.4544</span>, <span class="number">0.4519</span>, <span class="number">0.5535</span>],</span><br><span class="line">       [ <span class="number">0.5994</span>, <span class="number">0.8174</span>, <span class="number">0.</span> , <span class="number">0.</span> ]])</span><br></pre></td></tr></table></figure></p>
<h4 id="Fancy索引">Fancy索引</h4><p>Fancy索引是一个术语，被Numpy用来描述使用整形数组索引。假如我们有一个 8*4 的数组。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = np.empty((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"><span class="function"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title">range</span><span class="params">(<span class="number">8</span>)</span>:</span><br><span class="line">    arr[i] </span>= i</span><br><span class="line">arr</span><br><span class="line">	<span class="preprocessor">## array([[ 0., 0., 0., 0.],</span></span><br><span class="line">	<span class="preprocessor">##        [ 1., 1., 1., 1.],</span></span><br><span class="line">	<span class="preprocessor">##        [ 2., 2., 2., 2.],</span></span><br><span class="line">	<span class="preprocessor">##        [ 3., 3., 3., 3.],</span></span><br><span class="line">	<span class="preprocessor">##        [ 4., 4., 4., 4.],</span></span><br><span class="line">	<span class="preprocessor">##        [ 5., 5., 5., 5.],</span></span><br><span class="line">	<span class="preprocessor">##        [ 6., 6., 6., 6.],</span></span><br><span class="line">	<span class="preprocessor">##        [ 7., 7., 7., 7.]])</span></span><br></pre></td></tr></table></figure></p>
<p>为了选出一个有特定顺序行的子集，你可以传递一个列表或整形ndarray来指定想要的顺序。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr<span class="string">[[4, 3, 0, 6]]</span></span><br><span class="line">	## array(<span class="string">[[ 4., 4., 4., 4.],</span><br><span class="line">	##        [ 3., 3., 3., 3.],</span><br><span class="line">	##        [ 0., 0., 0., 0.],</span><br><span class="line">	##        [ 6., 6., 6., 6.]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>很庆幸这个代码做了你所期望的！使用负的索引从结尾选择行。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr<span class="string">[[-3, -5, -7]]</span></span><br><span class="line">	## array(<span class="string">[[ 5., 5., 5., 5.],</span><br><span class="line">	##        [ 3., 3., 3., 3.],</span><br><span class="line">	##        [ 1., 1., 1., 1.]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>传递多个索引数组有些微的不同，它选取一个一维数组，元素对应与索引的每一个元组。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">arr</span> = <span class="atom">np</span>.<span class="atom">arange</span>(<span class="number">32</span>).<span class="atom">reshape</span>((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"><span class="atom">arr</span></span><br><span class="line">	## <span class="atom">array</span>([[ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">	##        [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">	##        [ <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">	##        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">	##        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">	##        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">	##        [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>],</span><br><span class="line">	##        [<span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>]])</span><br><span class="line"><span class="atom">arr</span>[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">	## <span class="atom">array</span>([ <span class="number">4</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure></p>
<p>花一点儿时间来看看刚刚发生了什么：元素 (1, 0), (5, 3), (7, 1), 和(2, 2)被选择了。 fancy索引的行为与一些用户可能期望的有所不同，它因该是一个矩形区域，由选取的矩形的行和列组成。这里有一个方法来得到它。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="link_label">[1, 5, 7, 2</span>]][:, [0, 3, 1, 2]]</span><br><span class="line"><span class="code">	## array([[ 4, 7, 5, 6],</span></span><br><span class="line"><span class="code">	##        [20, 23, 21, 22],</span></span><br><span class="line"><span class="code">	##        [28, 31, 29, 30],</span></span><br><span class="line"><span class="code">	##        [ 8, 11, 9, 10]])</span></span><br></pre></td></tr></table></figure></p>
<p>另一种方法是使用 np.ix_ 函数，将两个以为整形数组转换为位标，来选取一个正方形区域：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">arr</span>[<span class="atom">np</span>.<span class="atom">ix_</span>([<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])]</span><br><span class="line">	## <span class="atom">array</span>([[ <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">	##        [<span class="number">20</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">22</span>],</span><br><span class="line">	##        [<span class="number">28</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">	##        [ <span class="number">8</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure></p>
<p>注意，fancy索引，不像切片，它总是拷贝数据到一个新的数组。</p>
<h3 id="转置数组和交换坐标轴">转置数组和交换坐标轴</h3><p>转置是一种特殊形式的变形，类似的它会返回基础数据的一个视窗，而不会拷贝任何东西。数组有 transpose 方法和专门的 T 属性：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">arr                  </span><br><span class="line">	## array(<span class="string">[[ 0, 1, 2, 3, 4],               </span><br><span class="line">	##        [ 5, 6, 7, 8, 9],               </span><br><span class="line">	##        [10, 11, 12, 13, 14]]</span>)          </span><br><span class="line">arr.T</span><br><span class="line">	## array(<span class="string">[[ 0, 5, 10],</span><br><span class="line">	##        [ 1, 6, 11],</span><br><span class="line">	##        [ 2, 7, 12],</span><br><span class="line">	##        [ 3, 8, 13],</span><br><span class="line">	##        [ 4, 9, 14]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>当进行矩阵运算时，你常常会这样做，像下面的例子一样，使用 np.dot 计算内部矩阵来产生 XTX` 。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">np.dot(arr.T, arr)</span><br><span class="line">	## array(<span class="string">[[ 2.584 , 1.8753, 0.8888],</span><br><span class="line">	##        [ 1.8753, 6.6636, 0.3884],</span><br><span class="line">	##        [ 0.8888, 0.3884, 3.9781]]</span>)</span><br></pre></td></tr></table></figure></p>
<p>对于更高维的数组， transpose 接受用于转置的坐标轴的号码的一个元组（for extra mind bending）：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line">	## array(<span class="string">[[[ 0, 1, 2, 3],</span><br><span class="line">	##         [ 4, 5, 6, 7]]</span>,</span><br><span class="line">	##        <span class="string">[[ 8, 9, 10, 11],</span><br><span class="line">	##         [12, 13, 14, 15]]</span>])</span><br><span class="line">arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">	## array(<span class="string">[[[ 0, 1, 2, 3],</span><br><span class="line">	##         [ 8, 9, 10, 11]]</span>,</span><br><span class="line">	##        <span class="string">[[ 4, 5, 6, 7],</span><br><span class="line">	##         [12, 13, 14, 15]]</span>])</span><br></pre></td></tr></table></figure></p>
<p>使用 .T 的转置，仅仅是交换坐标轴的一个特殊的情况。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arr                            			                   </span><br><span class="line">	## array(<span class="string">[[[ 0, 1, 2, 3],            </span><br><span class="line">	##         [ 4, 5, 6, 7]]</span>,                                     </span><br><span class="line">	##        <span class="string">[[ 8, 9, 10, 11],          </span><br><span class="line">	##         [12, 13, 14, 15]]</span>])                                      </span><br><span class="line">arr.swapaxes(<span class="number">1</span>, <span class="number">2</span>)          </span><br><span class="line">    ## array(<span class="string">[[[ 0, 4],</span><br><span class="line">    ##         [ 1, 5],</span><br><span class="line">    ##         [ 2, 6],</span><br><span class="line">    ##         [ 3, 7]]</span>,</span><br><span class="line">    ##        <span class="string">[[ 8, 12],</span><br><span class="line">    ##        [ 9, 13],</span><br><span class="line">    ##        [10, 14],</span><br><span class="line">    ##        [11, 15]]</span>])</span><br></pre></td></tr></table></figure></p>
<p>类似的 swapaxes 返回在数据上的一个视窗，而不进行拷贝。</p>
<h3 id="通用函数：快速的基于元素的数组函数">通用函数：快速的基于元素的数组函数</h3><p>一个通用的函数，是一个在ndarrays的数据上进行基于元素的操作的函数。你可以认为它们是对简单函数的一个快速矢量化封装，它们接受一个或多个标量值并产生一个或多个标量值。<br>许多 ufuncs 都是基于元素的简单变换，像 sqrt 或 exp 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iarr = np.arange(<span class="number">10</span>)</span><br><span class="line">Inp.<span class="built_in">sqrt</span>(arr)</span><br><span class="line">	<span class="preprocessor">## array([ 0. , 1. , 1.4142, 1.7321, 2. , 2.2361, 2.4495,</span></span><br><span class="line">	<span class="preprocessor">##         2.6458, 2.8284, 3. ])</span></span><br><span class="line">np.<span class="built_in">exp</span>(arr)</span><br><span class="line">	<span class="preprocessor">## array([ 1. , 2.7183, 7.3891, 20.0855, 54.5982,</span></span><br><span class="line">	<span class="preprocessor">##        148.4132, 403.4288, 1096.6332, 2980.958 , 8103.0839])</span></span><br></pre></td></tr></table></figure></p>
<p>这些归诸于unary ufuncs。其它的，例如add或maximum ，接受两个数组(因此，叫做binary ufuncs)且返回一个数组：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">x =</span> randn(<span class="number">8</span>)</span><br><span class="line"><span class="variable">y =</span> randn(<span class="number">8</span>)</span><br><span class="line">x</span><br><span class="line">	<span class="comment">## array([ 0.0749, 0.0974, 0.2002, -0.2551, 0.4655, 0.9222, 0.446 ,</span></span><br><span class="line">	<span class="comment">##        -0.9337])</span></span><br><span class="line">y</span><br><span class="line">	<span class="comment">## array([ 0.267 , -1.1131, -0.3361, 0.6117, -1.2323, 0.4788, 0.4315,</span></span><br><span class="line">	<span class="comment">##        -0.7147])</span></span><br><span class="line">np.maximum(x, y) <span class="comment"># element-wise maximum</span></span><br><span class="line">	<span class="comment">## array([ 0.267 , 0.0974, 0.2002, 0.6117, 0.4655, 0.9222, 0.446 ,</span></span><br><span class="line">	<span class="comment">##        -0.7147])</span></span><br></pre></td></tr></table></figure></p>
<p>虽然不常见，一个ufunc可以返回多个数组。 nodf 就是一个例子，它是python内建 divmod 的矢量化的版本：它返回一个 浮点数数组的分数和整数部分。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = randn(<span class="number">7</span>) * <span class="number">5</span></span><br><span class="line">np.<span class="built_in">modf</span>(arr)</span><br><span class="line">	<span class="preprocessor">##(array([-0.6808, 0.0636, -0.386 , 0.1393, -0.8806, 0.9363, -0.883 ]),</span></span><br><span class="line">	<span class="preprocessor">## array([-2., 4., -3., 5., -3., 3., -6.]))</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Unary ufuncs</strong><br>| 函数 |    描述 |<br>|:————:|:———-:|<br>| abs, fabs    | 计算基于元素的整形，浮点或复数的绝对值。fabs对于没有复数数据的快速版本 |<br>| sqrt    | 计算每个元素的平方根。等价于 arr <strong> 0.5 |<br>| square    | 计算每个元素的平方。等价于 arr </strong> 2 |<br>| exp    | 计算每个元素的指数。 |<br>| log, log10, log2, log1p |    自然对数（基于e），基于10的对数，基于2的对数和 log(1 + x) |<br>| sign    | 计算每个元素的符号：1(positive)，0(zero)， -1(negative) |<br>| ceil    | 计算每个元素的天花板，即大于或等于每个元素的最小值 |<br>| floor    | 计算每个元素的地板，即小于或等于每个元素的最大值 |<br>| rint    | 圆整每个元素到最近的整数，保留dtype |<br>| modf    | 分别返回分数和整数部分的数组 |<br>| isnan    | 返回布尔数组标识哪些元素是 NaN （不是一个数） |<br>| isfinite, isinf    | 分别返回布尔数组标识哪些元素是有限的（non-inf, non-NaN）或无限的 |<br>| cos, cosh, sin sinh, tan, tanh    | regular 和 hyperbolic三角函数 |<br>| arccos, arccosh, arcsin, arcsinh, arctan, arctanh     | 反三角函数 |<br>| logical_not    | 计算基于元素的非x的真值。等价于 -arr |<br>Binary universal funcitons<br>| 函数 |    描述 |<br>| ———— | ———-|<br>add    在数组中添加相应的元素<br>substract    在第一个数组中减去第二个数组<br>multiply    对数组元素相乘<br>divide, floor_divide    除和地板除（去掉余数）<br>power    使用第二个数组作为指数提升第一个数组中的元素<br>maximum, fmax    基于元素的最大值。 fmax 忽略 NaN<br>minimum, fmin    基于元素的最小值。 fmin 忽略 NaN<br>mod    基于元素的模（取余）<br>copysign    拷贝第二个参数的符号到第一个参数<br>greater, greater_equal, less, less_equal, not_equal    基于元素的比较，产生布尔数组。等价于中缀操作符 &gt;, &gt;=, &lt;, &lt;=, ==, !=<br>logical_and, logical_or, logical_xor    | 计算各个元素逻辑操作的真值。等价于中缀操作符 &amp;, |, ^</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-21T23:27:47.000Z"><a href="/2016/04/21/spatial-pattern-analysis/">4月21 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/21/spatial-pattern-analysis/">空间点格局分析</a></h1>
  

    </header>
    <div class="entry">
      
        <p>点格局分析可应用于科学研究的多个领域。在生态学上，研究的兴趣点主要集中一下几个方面：</p>
<ol>
<li>探究单一树种在研究区的分布</li>
<li>两个或以上物种是否均匀分布或者存在竞争关系</li>
<li>各个物种分布在研究区特定区域分布的驱动因子分析</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-21T21:46:58.000Z"><a href="/2016/04/21/dots-in-r/">4月21 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/21/dots-in-r/">实用的R函数</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这篇文章记录的是在使用R的过程中偶然遇到的非常实用的函数，然而由于这些函数在自己的学习中太常用特别容易忘记，所以这里记下来以便以后使用的时候可以查看。学无止境，长期更新。</p>
<h2 id="场景一">场景一</h2><p>在查看多个变量之间的两两相关性的时候，可以使用picante包中的cor.table()函数。</p>
<h2 id="场景二">场景二</h2><p>在R中加载了多个R包时，希望查看当前环境中都加载了哪些R包的find.package()函数，临时卸载某个R包可以使用函数detach(package:包名)。如要卸载dplyr包，则为detach(package:dplyr)。</p>
<h2 id="场景三">场景三</h2><p>expand.grid()用来建立一些factor相乘出来的矩阵或data.frame。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/04/21/dots-in-r/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-13T19:56:01.000Z"><a href="/2016/04/13/data-table-in-R/">4月13 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/13/data-table-in-R/">data.table的包的简单介绍</a></h1>
  

    </header>
    <div class="entry">
      
        <p>相比dplyr包，data.table包能够更大程度地提高数据的处理速度，这里就简单介绍一下data.tale包的使用方法。</p>
<h2 id="数据的读取">数据的读取</h2><p>data.table包中数据读取的函数是fread()。</p>
<h2 id="data-table_的创建">data.table 的创建</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">library(data.table)</span><br><span class="line"><span class="variable">DT =</span> data.table(<span class="variable">x=</span>rep(c(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>),<span class="variable">each=</span><span class="number">3</span>), <span class="variable">y=</span>c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>), <span class="variable">v=</span><span class="number">1</span>:<span class="number">9</span>)</span><br><span class="line">DT</span><br><span class="line">	<span class="comment">#    x y v</span></span><br><span class="line">	<span class="comment"># 1: a 1 1</span></span><br><span class="line">	<span class="comment"># 2: a 3 2</span></span><br><span class="line">	<span class="comment"># 3: a 6 3</span></span><br><span class="line">	<span class="comment"># 4: b 1 4</span></span><br><span class="line">	<span class="comment"># 5: b 3 5</span></span><br><span class="line">	<span class="comment"># 6: b 6 6</span></span><br><span class="line">	<span class="comment"># 7: c 1 7</span></span><br><span class="line">	<span class="comment"># 8: c 3 8</span></span><br><span class="line">	<span class="comment"># 9: c 6 9</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/04/13/data-table-in-R/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-10T16:32:19.000Z"><a href="/2016/04/10/data-fomrat/">4月10 2016</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/10/data-fomrat/">长宽数据之间的转化(二)</a></h1>
  

    </header>
    <div class="entry">
      
        <p>前面一篇<a href="http://xukuang.github.io/2016/01/18/melt-and-dcast/">文章</a>讲了用reshape2包中的函数实现长宽数据的转化，而tidyr是reshape2的升级版，主要用于数据框。这篇文章将介绍一下如何使用tidyr包中的函数实现长宽数据的转化。</p>
<h2 id="宽数据转化为长数据">宽数据转化为长数据</h2><h3 id="gather函数">gather函数</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gather(<span class="built_in">data</span>, key, value, <span class="attribute">...</span>, na<span class="built_in">.</span>rm <span class="subst">=</span> <span class="literal">FALSE</span>, convert <span class="subst">=</span> <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<p><strong>data</strong> 要转化的数据，数据格式为数据框类型或者可以转化为数据框类型<br><strong>key</strong>  指定转化后数据框的指标列的列名，用于存放原数据中不同的数据指标<br><strong>value</strong>  指定转化后数据框的数据列的列名，用于存放原数据中不同的数据指标对应的值<br><strong>…</strong> 指定哪些列聚到一列中。按那些列数据作为标准转化，这个参数接不能有那些列<br><strong>na.rm</strong> 确定是否去除数据中的NA，默认情况下为FALSE，不去除NA<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/04/10/data-fomrat/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:xukuang.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/学习篇/">学习篇</a><small>4</small></li>
  
    <li><a href="/categories/心理篇/">心理篇</a><small>2</small></li>
  
    <li><a href="/categories/技术篇/">技术篇</a><small>22</small></li>
  
    <li><a href="/categories/生活篇/">生活篇</a><small>3</small></li>
  
    <li><a href="/categories/读书篇/">读书篇</a><small>7</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/R/" style="font-size: 20px;">R</a><a href="/tags/data-talbe/" style="font-size: 10px;">data.talbe</a><a href="/tags/dplyr/" style="font-size: 15px;">dplyr</a><a href="/tags/dropbox/" style="font-size: 10px;">dropbox</a><a href="/tags/hexo/" style="font-size: 12.5px;">hexo</a><a href="/tags/numpy/" style="font-size: 10px;">numpy</a><a href="/tags/plyr/" style="font-size: 12.5px;">plyr</a><a href="/tags/python/" style="font-size: 15px;">python</a><a href="/tags/reshape2/" style="font-size: 10px;">reshape2</a><a href="/tags/tidyr/" style="font-size: 10px;">tidyr</a><a href="/tags/三维图/" style="font-size: 10px;">三维图</a><a href="/tags/坐标轴/" style="font-size: 10px;">坐标轴</a><a href="/tags/坚持/" style="font-size: 12.5px;">坚持</a><a href="/tags/娱乐/" style="font-size: 10px;">娱乐</a><a href="/tags/援助/" style="font-size: 10px;">援助</a><a href="/tags/摘录/" style="font-size: 17.5px;">摘录</a><a href="/tags/数据合并/" style="font-size: 12.5px;">数据合并</a><a href="/tags/文件系统管理/" style="font-size: 10px;">文件系统管理</a><a href="/tags/文本/" style="font-size: 10px;">文本</a><a href="/tags/旁观者/" style="font-size: 10px;">旁观者</a><a href="/tags/空间格局分析/" style="font-size: 10px;">空间格局分析</a><a href="/tags/统计/" style="font-size: 12.5px;">统计</a><a href="/tags/美食/" style="font-size: 10px;">美食</a><a href="/tags/英语/" style="font-size: 10px;">英语</a><a href="/tags/计划/" style="font-size: 10px;">计划</a><a href="/tags/重命名/" style="font-size: 10px;">重命名</a><a href="/tags/高调/" style="font-size: 10px;">高调</a>
  </div>
</div>


  <div class="widget tag">
<h3 class="title">简介</font></h3>
<ul class="entry">
<li>姓名：<a href=http://xukuang.github.io/about/>匡旭</a></li>
<li>现状：博士在读</li>
<li>Theme: <a href="https://github.com/zippera/lightum">Lightum</a></li>
<li>QQ: <font color="red">530731251</font></li>
</ul>
</div>



  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3051539547&verifier=655ac839&colors=ffffff,d3f9bc,464646,0082cb,ecfbfd&dpc=1"></iframe>

  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://zipperary.com/" title="Zippera's Blog">Zippera</a></li>
<li><a href="http://jianshu.io/">简书</a></li>
</ul>
</div
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="outer">
    <div id="footer-info" class="inner" style="text-align:center;">
      <table width="100%" border="0">
        <tr>
          <td style="text-align:left" bgcolor="white">
            Copyright &copy; 2014-2016 <a href="http://xukuang.github.io/about/" target="_blank">Xu Kuang</a> &nbsp; &nbsp;<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
            Theme <a href="https://github.com/zippera/lightum" target="_blank">Lightum</a>&nbsp; &nbsp;
            Hosted on <a href="http://github.com/" target="_blank">GitHub</a>
          </td>
        </tr>
      </table>
    </div>
</div></footer>
  <script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
<a title="返回顶部"><img src="/imgs/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
</body>
</html>

